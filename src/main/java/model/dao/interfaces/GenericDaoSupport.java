package model.dao.interfaces;

import exceptions.*;
import model.database.ConnectionProvider;
import model.entities.Entity;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Generic abstract class that provides generic protected methods for executing of CRUD operations
 * @param <E> - type of entity over which CRUD operations are performed
 */
public abstract class GenericDaoSupport<E extends Entity> {

    /**
     * Generic method, that provides support for executing of create/insert operation
     * @param entity - instance of entity that should be inserted
     * @param query - string, that represents sql query which is used for prepared statement's creation
     * @return autogenerated id of inserted record
     * @throws SQLException
     */
    protected long insertEntity(E entity, String query) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query, Statement.RETURN_GENERATED_KEYS)) {
            setQueryParameters(preparedStatement, entity);
            System.out.println(preparedStatement);
            preparedStatement.executeUpdate();
            ResultSet resultSet = preparedStatement.getGeneratedKeys();
            if (resultSet.next())
                return resultSet.getLong(1);
            throw new ErrorMessageKeysContainedException(List.of("error.sql.insert"));
        } catch (SQLIntegrityConstraintViolationException e) {
            throw new ErrorMessageKeysContainedException(List.of("error.sql.data_integrity"));
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    /**
     * Generic method, that provides support for executing of update operation
     * @param entity - instance of entity that should be inserted
     * @param query - string, that represents sql query which is used for prepared statement's creation
     * @throws SQLException
     */
    protected void updateEntity(E entity, String query) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query)) {
            setQueryParameters(preparedStatement, entity);
            preparedStatement.executeUpdate();
        } catch (SQLIntegrityConstraintViolationException e) {
            throw new ErrorMessageKeysContainedException(List.of("error.sql.data_integrity"));
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    protected void deleteEntity(String query) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query)) {
            preparedStatement.executeUpdate();
        } catch (SQLIntegrityConstraintViolationException e) {
            throw new ErrorMessageKeysContainedException(List.of("error.sql.data_integrity"));
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    protected List<E> selectEntities(String query, ResultSetRowParser<E> resultSetRowParser, Object... conditionParams) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query)) {
            for (int i = 0; i < conditionParams.length; i++) {
                preparedStatement.setObject(i + 1, conditionParams[i]);
            }
            List<E> entities = new ArrayList<>();
            ResultSet resultSet = preparedStatement.executeQuery();
            while (resultSet.next()) {
                entities.add(resultSetRowParser.parseResultSetRow(resultSet));
            }
            return entities;
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    protected List<E> selectEntities(String query, Object... conditionParams) {
        return selectEntities(query, this::getSingleResult, conditionParams);
    }

    /**
     * Method, which supports select operation, that should return a single result
     * @param query - string, that represents sql select query which is used for prepared statement's creation
     * @param resultSetRowParser - an implementation of ResultSetRowParser interface, which is used for
     *                           getting of entity from ResultSet row
     * @param conditionParams - values of params, that should be specified in PreparedStatement
     * @return a single instance of entity
     * @throws SQLException
     */
    protected E selectEntity(String query, ResultSetRowParser<E> resultSetRowParser, Object... conditionParams) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query)) {
            for (int i = 0; i < conditionParams.length; i++) {
                preparedStatement.setObject(i + 1, conditionParams[i]);
            }
            ResultSet resultSet = preparedStatement.executeQuery();
            if (resultSet.next()) {
                return resultSetRowParser.parseResultSetRow(resultSet);
            }
            throw new EntityNotFoundException("error.sql.not_found");
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    /**
     * Facade selectEntity() method overload, which supports select operation, that should return a single result
     * and uses getSingleResult() method as a default ResultSetRowParser implementation
     * @param query - string, that represents sql select query which is used for prepared statement's creation
     * @param conditionParams - values of params, that should be specified in PreparedStatement
     * @return a single instance of entity
     * @throws SQLException
     */
    protected E selectEntity(String query, Object... conditionParams) {
        return selectEntity(query, this::getSingleResult, conditionParams);
    }

    protected long selectCountOfEntities(String query, Object... conditionParams) {
        Connection connection = ConnectionProvider.getConnection();
        try (PreparedStatement preparedStatement = connection.prepareStatement(
                query)) {
            for (int i = 0; i < conditionParams.length; i++) {
                preparedStatement.setObject(i + 1, conditionParams[i]);
            }
            ResultSet resultSet = preparedStatement.executeQuery();
            resultSet.next();
            return resultSet.getLong(1);
        } catch (SQLException e) {
            throw new UnknownSqlException(e.getMessage());
        }
    }

    /**
     * Abstract method, that extracts entity fields from the current row of the provided ResultSet,
     * and can be used as implementation of ResultSetRowParser functional interface
     * @param resultSet ResultSet, which current row should be parsed to entity fields
     * @return the instance of entity, with fields parsed from ResultSet
     * @throws SQLException
     */
    protected abstract E getSingleResult(ResultSet resultSet) throws EntitySQLParseException;

    /**
     * Abstract method, which is used for setting up PreparedStatement parameters, basing on entity's fields values
     * @param preparedStatement - PreparedStatement, for which parameters should be specified
     * @param entity - entity, which field values are used for specifying preparedStatement's parameters
     * @return modified preparedStatement with set parameters
     * @throws SQLException
     */
    protected abstract PreparedStatement setQueryParameters(PreparedStatement preparedStatement, E entity)
        throws QueryPreparationException;

    /**
     * Functional interface, that contains one abstract method, that returns an instance of entity
     * with field values, extracted from the current row of provided ResultSet
     * @param <E> type of entity that should be parsed from ResultSet row
     */
    @FunctionalInterface
    protected interface ResultSetRowParser<E> {
        /**
         * Abstract method, that extracts entity from the current row of provided ResultSet
         * @param resultSet ResultSet, which current row should be parsed to entity
         * @return instance of entity, parsed from ResultSet
         * @throws SQLException
         */
        E parseResultSetRow(ResultSet resultSet) throws EntitySQLParseException;
    }
}
